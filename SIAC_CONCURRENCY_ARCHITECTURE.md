# üèóÔ∏è ARQUITECTURA DE CONCURRENCIA SIAC
## Soluci√≥n a 20 A√±os de Limitaciones de Access

---

## üéØ **PROBLEMA ORIGINAL EN ACCESS/DELPHI**

### **Limitaciones Identificadas:**
- ‚ùå **Access no soporta concurrencia real** (m√°ximo 10-15 usuarios)
- ‚ùå **Tablas locales por terminal** para evitar conflictos
- ‚ùå **Numeraci√≥n duplicada** en operaciones simult√°neas
- ‚ùå **Locks primitivos** que bloquean toda la tabla
- ‚ùå **P√©rdida de datos** en ca√≠das de conexi√≥n

### **Escenario Cr√≠tico:**
```
üè™ SUPERMERCADO CON 20 CAJAS REGISTRADORAS
‚îú‚îÄ‚îÄ Caja 01: Facturando producto A
‚îú‚îÄ‚îÄ Caja 02: Facturando producto A (MISMO)
‚îú‚îÄ‚îÄ Caja 03: Generando recibo
‚îú‚îÄ‚îÄ ...
‚îî‚îÄ‚îÄ Caja 20: Orden de pago

‚ùå PROBLEMA: Numeraci√≥n duplicada, conflictos de datos
```

---

## üöÄ **SOLUCI√ìN POSTGRESQL MODERNA**

### **Principios Arquitect√≥nicos:**

#### **1. CONFIGURACI√ìN GLOBAL (por empresa)**
- ‚úÖ **Una configuraci√≥n** por empresa (company_id)
- ‚úÖ **Aplicaci√≥n universal** a todas las sesiones
- ‚úÖ **Cambios centralizados** con propagaci√≥n autom√°tica

#### **2. CONFIGURACI√ìN LOCAL (por terminal/sesi√≥n)**
- ‚úÖ **Aislaci√≥n total** entre terminales
- ‚úÖ **Tablas temporales** en memoria por sesi√≥n
- ‚úÖ **Recovery autom√°tico** en ca√≠das

#### **3. NUMERACI√ìN CENTRALIZADA SEGURA**
- ‚úÖ **Transacciones ACID** para numeraci√≥n √∫nica
- ‚úÖ **Row-level locking** sin bloquear toda la tabla
- ‚úÖ **Rollback autom√°tico** en errores

---

## üìä **ESTRUCTURA DE BASE DE DATOS**

### **Tabla 1: Configuraci√≥n Global**
```sql
-- YA EXISTE: siac_configuracion_empresa
-- Configuraciones que aplican a TODA la empresa
CREATE TABLE siac_configuracion_empresa (
    id SERIAL PRIMARY KEY,
    company_id INTEGER UNIQUE NOT NULL,

    -- DATOS GLOBALES DE LA EMPRESA
    razon_social VARCHAR(255),
    cuit VARCHAR(15),
    punto_venta INTEGER DEFAULT 1,

    -- NUMERACI√ìN CENTRALIZADA
    factura_a_numero INTEGER DEFAULT 1,
    factura_b_numero INTEGER DEFAULT 1,
    recibo_numero INTEGER DEFAULT 1,

    -- CONFIGURACI√ìN FISCAL GLOBAL
    agente_retencion_iva BOOLEAN DEFAULT false,
    pais VARCHAR(3) DEFAULT 'ARG',

    -- AUDITOR√çA
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

### **Tabla 2: Sesiones Locales**
```sql
-- NUEVA: Control de sesiones por terminal
CREATE TABLE siac_sesiones_locales (
    id SERIAL PRIMARY KEY,
    company_id INTEGER NOT NULL,

    -- IDENTIFICACI√ìN DE SESI√ìN
    session_id VARCHAR(100) UNIQUE NOT NULL, -- UUID √∫nico
    terminal_id VARCHAR(50) NOT NULL,        -- "CAJA_01", "MOSTRADOR_02"
    user_id INTEGER NOT NULL,                -- Usuario logueado

    -- DATOS TEMPORALES DE LA SESI√ìN
    facturacion_temp JSONB DEFAULT '[]',     -- Items en facturaci√≥n
    recibos_temp JSONB DEFAULT '[]',         -- Pagos temporales
    ordenes_pago_temp JSONB DEFAULT '[]',    -- √ìrdenes temporales

    -- CONTROL DE CONCURRENCIA
    is_active BOOLEAN DEFAULT true,
    locked_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    last_activity TIMESTAMP DEFAULT CURRENT_TIMESTAMP,

    -- CONFIGURACI√ìN LOCAL ESPEC√çFICA
    configuracion_local JSONB DEFAULT '{}', -- Printer, display, etc.

    -- AUDITOR√çA
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,

    -- CONSTRAINT
    UNIQUE(company_id, terminal_id) -- Un terminal = una sesi√≥n activa
);
```

### **Tabla 3: Log de Numeraci√≥n**
```sql
-- NUEVA: Auditor√≠a de numeraci√≥n para debugging
CREATE TABLE siac_numeracion_log (
    id SERIAL PRIMARY KEY,
    company_id INTEGER NOT NULL,
    tipo_comprobante VARCHAR(50) NOT NULL,  -- "facturaA", "recibo"
    numero_asignado INTEGER NOT NULL,
    session_id VARCHAR(100),
    user_id INTEGER,
    terminal_id VARCHAR(50),
    timestamp_asignacion TIMESTAMP DEFAULT CURRENT_TIMESTAMP,

    -- PARA AUDITOR√çA
    ip_address INET,
    user_agent TEXT
);
```

---

## ‚öôÔ∏è **SISTEMA DE NUMERACI√ìN CONCURRENTE**

### **Algoritmo de Numeraci√≥n Segura:**

```javascript
/**
 * PASO 1: Obtener pr√≥ximo n√∫mero de forma at√≥mica
 * - Usa transacciones PostgreSQL
 * - Row-level locking
 * - Rollback autom√°tico en error
 */
async function obtenerProximoNumeroSeguro(companyId, tipoComprobante, sessionData) {
    const transaction = await sequelize.transaction({
        isolationLevel: Transaction.ISOLATION_LEVELS.SERIALIZABLE
    });

    try {
        // LOCK espec√≠fico en la fila de la empresa
        const config = await ConfiguracionEmpresa.findOne({
            where: { companyId },
            lock: {
                level: transaction.LOCK.UPDATE,
                of: ConfiguracionEmpresa
            },
            transaction
        });

        if (!config) {
            throw new Error('Configuraci√≥n de empresa no encontrada');
        }

        // Incrementar n√∫mero de forma at√≥mica
        const numeroActual = config.getProximoNumero(tipoComprobante);
        const nuevoNumero = numeroActual + 1;

        // Actualizar en base de datos
        await config.update({
            [`${tipoComprobante}Numero`]: nuevoNumero
        }, { transaction });

        // Registrar en log para auditor√≠a
        await LogNumeracion.create({
            companyId,
            tipoComprobante,
            numeroAsignado: numeroActual,
            sessionId: sessionData.sessionId,
            userId: sessionData.userId,
            terminalId: sessionData.terminalId,
            ipAddress: sessionData.ipAddress
        }, { transaction });

        // COMMIT si todo sali√≥ bien
        await transaction.commit();

        return {
            numeroAsignado: numeroActual,
            siguienteNumero: nuevoNumero,
            timestamp: new Date(),
            sessionId: sessionData.sessionId
        };

    } catch (error) {
        // ROLLBACK autom√°tico en cualquier error
        await transaction.rollback();

        console.error('Error en numeraci√≥n concurrente:', error);
        throw new Error(`Error obteniendo n√∫mero: ${error.message}`);
    }
}
```

---

## üñ•Ô∏è **GESTI√ìN DE SESIONES LOCALES**

### **Manager de Sesiones:**

```javascript
/**
 * SESI√ìN MANAGER
 * Maneja el ciclo de vida completo de sesiones por terminal
 */
class SiacSessionManager {

    /**
     * CREAR NUEVA SESI√ìN
     * - Genera UUID √∫nico
     * - Registra terminal y usuario
     * - Inicializa tablas temporales
     */
    static async crearSesion(companyId, terminalId, userId, ipAddress) {
        const sessionId = `siac_${companyId}_${terminalId}_${Date.now()}_${uuidv4()}`;

        // Verificar si el terminal ya tiene sesi√≥n activa
        const sesionExistente = await SesionLocal.findOne({
            where: {
                companyId,
                terminalId,
                isActive: true
            }
        });

        if (sesionExistente) {
            // Cerrar sesi√≥n anterior autom√°ticamente
            await this.cerrarSesion(sesionExistente.sessionId, 'Nueva sesi√≥n iniciada');
        }

        // Crear nueva sesi√≥n
        const nuevaSesion = await SesionLocal.create({
            companyId,
            sessionId,
            terminalId,
            userId,
            facturacionTemp: [],
            recibosTemp: [],
            ordenesPagoTemp: [],
            configuracionLocal: {
                impresora: `PRINTER_${terminalId}`,
                display: `DISPLAY_${terminalId}`,
                ipAddress
            }
        });

        console.log(`‚úÖ Sesi√≥n creada: ${sessionId} en ${terminalId}`);
        return nuevaSesion;
    }

    /**
     * AGREGAR ITEM TEMPORAL
     * - Agrega item a tabla temporal de la sesi√≥n
     * - Mantiene aislaci√≥n total entre terminales
     */
    static async agregarItemTemporal(sessionId, tipoTabla, item) {
        const sesion = await SesionLocal.findOne({
            where: { sessionId, isActive: true }
        });

        if (!sesion) {
            throw new Error('Sesi√≥n no encontrada o inactiva');
        }

        // Agregar item a la tabla temporal correspondiente
        const tablaActual = sesion[`${tipoTabla}Temp`] || [];
        tablaActual.push({
            ...item,
            id: uuidv4(),
            timestamp: new Date(),
            sessionId
        });

        // Actualizar sesi√≥n
        await sesion.update({
            [`${tipoTabla}Temp`]: tablaActual,
            lastActivity: new Date()
        });

        return tablaActual;
    }

    /**
     * CONFIRMAR OPERACI√ìN
     * - Mueve datos temporales a tablas definitivas
     * - Transacci√≥n at√≥mica para consistencia
     */
    static async confirmarOperacion(sessionId, tipoOperacion, datosConfirmacion) {
        const transaction = await sequelize.transaction();

        try {
            const sesion = await SesionLocal.findOne({
                where: { sessionId, isActive: true },
                transaction
            });

            if (!sesion) {
                throw new Error('Sesi√≥n no encontrada');
            }

            // Obtener n√∫mero de comprobante
            const numeroComprobante = await this.obtenerProximoNumeroSeguro(
                sesion.companyId,
                tipoOperacion,
                {
                    sessionId: sesion.sessionId,
                    userId: sesion.userId,
                    terminalId: sesion.terminalId,
                    ipAddress: sesion.configuracionLocal?.ipAddress
                }
            );

            // Crear registro definitivo (ejemplo: factura)
            const registroDefinitivo = await this.crearRegistroDefinitivo(
                tipoOperacion,
                sesion,
                numeroComprobante,
                datosConfirmacion,
                transaction
            );

            // Limpiar tabla temporal
            await sesion.update({
                [`${tipoOperacion}Temp`]: [],
                lastActivity: new Date()
            }, { transaction });

            await transaction.commit();

            return {
                success: true,
                numeroComprobante: numeroComprobante.numeroAsignado,
                registroId: registroDefinitivo.id,
                sessionId
            };

        } catch (error) {
            await transaction.rollback();
            throw error;
        }
    }

    /**
     * CERRAR SESI√ìN
     * - Limpia datos temporales
     * - Libera terminal para nueva sesi√≥n
     */
    static async cerrarSesion(sessionId, motivo = 'Sesi√≥n finalizada') {
        const sesion = await SesionLocal.findOne({
            where: { sessionId }
        });

        if (sesion) {
            await sesion.update({
                isActive: false,
                lastActivity: new Date(),
                configuracionLocal: {
                    ...sesion.configuracionLocal,
                    motivoCierre: motivo,
                    fechaCierre: new Date()
                }
            });

            console.log(`üîí Sesi√≥n cerrada: ${sessionId} - ${motivo}`);
        }
    }

    /**
     * CLEANUP AUTOM√ÅTICO
     * - Cierra sesiones inactivas (m√°s de 2 horas)
     * - Se ejecuta cada 30 minutos
     */
    static async cleanupSesionesInactivas() {
        const doHorasAtras = new Date(Date.now() - (2 * 60 * 60 * 1000));

        const sesionesInactivas = await SesionLocal.findAll({
            where: {
                isActive: true,
                lastActivity: {
                    [Op.lt]: doHorasAtras
                }
            }
        });

        for (const sesion of sesionesInactivas) {
            await this.cerrarSesion(sesion.sessionId, 'Timeout por inactividad');
        }

        console.log(`üßπ Cleanup: ${sesionesInactivas.length} sesiones cerradas por inactividad`);
    }
}

// Programar cleanup autom√°tico cada 30 minutos
setInterval(() => {
    SiacSessionManager.cleanupSesionesInactivas().catch(console.error);
}, 30 * 60 * 1000);
```

---

## üîÑ **FLUJO COMPLETO: 20 CAJAS SIMULT√ÅNEAS**

### **Escenario Real:**

```
üè™ SUPERMERCADO "LA ECONOM√çA" - 20 CAJAS OPERANDO
üìÖ Viernes 15:30 PM - Hora pico

üñ•Ô∏è CAJA_01 (Vendedora: Maria)
‚îú‚îÄ‚îÄ Session: siac_21_CAJA_01_1695482100_uuid1
‚îú‚îÄ‚îÄ Usuario: maria@supereco.com
‚îú‚îÄ‚îÄ Productos temporales: [Coca Cola, Pan, Leche]
‚îî‚îÄ‚îÄ Status: ‚ö° Facturando

üñ•Ô∏è CAJA_02 (Vendedor: Carlos)
‚îú‚îÄ‚îÄ Session: siac_21_CAJA_02_1695482101_uuid2
‚îú‚îÄ‚îÄ Usuario: carlos@supereco.com
‚îú‚îÄ‚îÄ Productos temporales: [Arroz, Fideos, Aceite]
‚îî‚îÄ‚îÄ Status: ‚ö° Generando ticket

üñ•Ô∏è CAJA_03 (Supervisor: Ana)
‚îú‚îÄ‚îÄ Session: siac_21_CAJA_03_1695482102_uuid3
‚îú‚îÄ‚îÄ Usuario: ana@supereco.com
‚îú‚îÄ‚îÄ Recibo temporal: Cliente Juan Perez - $15,000
‚îî‚îÄ‚îÄ Status: ‚ö° Procesando pago

... (17 cajas m√°s operando simult√°neamente)

üìä NUMERACI√ìN CENTRALIZADA:
‚îú‚îÄ‚îÄ Factura A: pr√≥ximo 001547 üîí (locked por CAJA_01)
‚îú‚îÄ‚îÄ Factura B: pr√≥ximo 002891 üîí (locked por CAJA_02)
‚îú‚îÄ‚îÄ Ticket: pr√≥ximo 045672 üîí (locked por CAJA_05)
‚îî‚îÄ‚îÄ Recibo: pr√≥ximo 001123 üîí (locked por CAJA_03)

‚úÖ RESULTADO: Cero conflictos, numeraci√≥n √∫nica, datos aislados
```

### **Flujo de Operaci√≥n:**

```mermaid
sequenceDiagram
    participant C1 as Caja 01
    participant C2 as Caja 02
    participant DB as PostgreSQL
    participant SM as Session Manager

    C1->>SM: Iniciar sesi√≥n (CAJA_01, Maria)
    SM->>DB: CREATE session siac_21_CAJA_01_uuid1
    DB-->>SM: ‚úÖ Sesi√≥n creada

    C2->>SM: Iniciar sesi√≥n (CAJA_02, Carlos)
    SM->>DB: CREATE session siac_21_CAJA_02_uuid2
    DB-->>SM: ‚úÖ Sesi√≥n creada

    C1->>SM: Agregar producto (Coca Cola)
    SM->>DB: UPDATE facturacion_temp CAJA_01
    DB-->>SM: ‚úÖ Producto agregado

    C2->>SM: Agregar producto (Arroz)
    SM->>DB: UPDATE facturacion_temp CAJA_02
    DB-->>SM: ‚úÖ Producto agregado

    C1->>SM: Confirmar factura
    SM->>DB: BEGIN TRANSACTION
    DB->>DB: LOCK configuracion_empresa
    DB->>DB: GET pr√≥ximo n√∫mero Factura A
    DB->>DB: INCREMENT facturaA_numero
    DB->>DB: CREATE factura definitiva
    DB->>DB: CLEAR facturacion_temp CAJA_01
    DB->>DB: COMMIT TRANSACTION
    DB-->>SM: ‚úÖ Factura A-001547 creada

    C2->>SM: Confirmar factura (simult√°nea)
    SM->>DB: BEGIN TRANSACTION
    DB->>DB: LOCK configuracion_empresa
    DB->>DB: GET pr√≥ximo n√∫mero Factura B
    DB->>DB: INCREMENT facturaB_numero
    DB->>DB: CREATE factura definitiva
    DB->>DB: CLEAR facturacion_temp CAJA_02
    DB->>DB: COMMIT TRANSACTION
    DB-->>SM: ‚úÖ Factura B-002891 creada
```

---

## üõ°Ô∏è **VENTAJAS vs SISTEMA ORIGINAL ACCESS**

| Aspecto | Access/Delphi (Original) | PostgreSQL/Node.js (Nuevo) |
|---------|-------------------------|---------------------------|
| **Concurrencia** | ‚ùå 10-15 usuarios m√°ximo | ‚úÖ 100+ usuarios simult√°neos |
| **Numeraci√≥n** | ‚ùå Duplicados frecuentes | ‚úÖ Numeraci√≥n √∫nica garantizada |
| **Aislaci√≥n** | ‚ùå Tablas compartidas | ‚úÖ Sesiones completamente aisladas |
| **Recovery** | ‚ùå P√©rdida de datos temporal | ‚úÖ Recovery autom√°tico |
| **Auditor√≠a** | ‚ùå Log b√°sico | ‚úÖ Auditor√≠a completa |
| **Escalabilidad** | ‚ùå Limitado por Access | ‚úÖ Escalabilidad ilimitada |
| **Performance** | ‚ùå Degradaci√≥n con usuarios | ‚úÖ Performance constante |
| **Mantenimiento** | ‚ùå Complejo y manual | ‚úÖ Autom√°tico y monitoreable |

---

## üìà **M√âTRICAS DE PERFORMANCE ESPERADAS**

### **Benchmarks Objetivo:**
- ‚úÖ **20 terminales simult√°neas** sin degradaci√≥n
- ‚úÖ **< 100ms** tiempo de respuesta para numeraci√≥n
- ‚úÖ **99.9% uptime** sin p√©rdida de datos
- ‚úÖ **0 duplicados** en numeraci√≥n de comprobantes
- ‚úÖ **Recovery < 5 segundos** ante ca√≠das de conexi√≥n

### **Monitoring Autom√°tico:**
```javascript
// M√©tricas en tiempo real
const metrics = {
    sesionesActivas: () => SesionLocal.count({ where: { isActive: true } }),
    numeracionesPorMinuto: () => LogNumeracion.count({
        where: {
            timestampAsignacion: {
                [Op.gte]: new Date(Date.now() - 60000)
            }
        }
    }),
    tiempoPromedioNumeracion: () => calculateAverageResponseTime(),
    conflictosConcurrencia: () => detectConcurrencyIssues()
};
```

---

## üéØ **PR√ìXIMOS PASOS DE IMPLEMENTACI√ìN**

1. ‚úÖ **Crear tablas de sesiones locales**
2. ‚úÖ **Implementar Session Manager**
3. ‚úÖ **Desarrollar APIs de concurrencia**
4. ‚úÖ **Testing con m√∫ltiples sesiones simult√°neas**
5. ‚úÖ **Integrar con interfaz de usuario**
6. ‚úÖ **Monitoring y alertas**

---

**üìã Documento actualizado:** 2025-09-23
**üéØ Estado:** Arquitectura definida - Lista para implementaci√≥n
**üë®‚Äçüíª Responsable:** Claude Code - Director del Proyecto