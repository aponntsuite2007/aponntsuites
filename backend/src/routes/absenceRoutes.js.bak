const express = require('express');
const router = express.Router();
const multer = require('multer');
const path = require('path');
const fs = require('fs').promises;
const { body, validationResult } = require('express-validator');

// Middleware y servicios
const auth = require('../middleware/auth');
const notificationService = require('../services/notificationService');

// Configurar multer para subida de archivos
const storage = multer.diskStorage({
  destination: async (req, file, cb) => {
    const uploadPath = path.join(__dirname, '../../uploads/absence');
    try {
      await fs.mkdir(uploadPath, { recursive: true });
      cb(null, uploadPath);
    } catch (error) {
      cb(error);
    }
  },
  filename: (req, file, cb) => {
    const uniqueSuffix = Date.now() + '-' + Math.round(Math.random() * 1E9);
    cb(null, `absence-${uniqueSuffix}${path.extname(file.originalname)}`);
  }
});

const upload = multer({ 
  storage: storage,
  fileFilter: (req, file, cb) => {
    const allowedTypes = /jpeg|jpg|png|pdf|doc|docx/;
    const extname = allowedTypes.test(path.extname(file.originalname).toLowerCase());
    const mimetype = allowedTypes.test(file.mimetype);
    
    if (mimetype && extname) {
      return cb(null, true);
    } else {
      cb(new Error('Solo se permiten archivos de imagen, PDF y documentos'));
    }
  },
  limits: { fileSize: 10 * 1024 * 1024 } // 10MB límite
});

// Base de datos simulada para notificaciones de inasistencia
let absenceNotifications = [];
let notificationIdCounter = 1;

// Crear notificación de inasistencia
router.post('/notify',
  // auth,
  [
    body('absenceType').isIn(['medical', 'personal', 'maternity', 'study', 'emergency'])
      .withMessage('Tipo de inasistencia inválido'),
    body('startDate').isISO8601().withMessage('Fecha de inicio inválida'),
    body('reason').notEmpty().withMessage('El motivo es obligatorio'),
    body('employeeName').notEmpty().withMessage('Nombre del empleado es obligatorio'),
  ],
  async (req, res) => {
    try {
      const errors = validationResult(req);
      if (!errors.isEmpty()) {
        return res.status(400).json({
          success: false,
          error: 'Datos inválidos',
          details: errors.array()
        });
      }

      const {
        absenceType,
        startDate,
        endDate,
        reason,
        notes,
        notifyHR,
        notifyDoctor,
        doctorEmail,
        employeeId,
        employeeName,
        hasAttachment
      } = req.body;

      // Crear registro de notificación
      const notification = {
        id: `abs-${notificationIdCounter++}`,
        employeeId: employeeId || req.user.id,
        employeeName: employeeName || `${req.user.firstName} ${req.user.lastName}`,
        absenceType,
        startDate: new Date(startDate),
        endDate: endDate ? new Date(endDate) : null,
        reason,
        notes: notes || null,
        hasAttachment,
        documentPath: null,
        status: 'pending',
        createdAt: new Date(),
        processedAt: null,
        processedBy: null,
        responses: {
          hr: notifyHR,
          doctor: notifyDoctor,
          doctorEmail
        },
        notificationsSent: {
          sms: false,
          whatsapp: false,
          email: false,
          hrNotified: false,
          doctorNotified: false
        }
      };

      absenceNotifications.push(notification);

      // Enviar notificaciones fehacientes
      try {
        const absenceTypeNames = {
          'medical': 'Médica',
          'personal': 'Personal',
          'maternity': 'Maternidad/Paternidad',
          'study': 'Estudio',
          'emergency': 'Emergencia'
        };

        const absenceTypeName = absenceTypeNames[absenceType] || absenceType;
        const formatDate = (date) => new Date(date).toLocaleDateString('es-ES');
        const dateRange = endDate ? 
          `${formatDate(startDate)} al ${formatDate(endDate)}` : 
          formatDate(startDate);

        const notificationContent = `
NOTIFICACIÓN DE INASISTENCIA

👤 Empleado: ${employeeName}
📅 Fecha(s): ${dateRange}
🏥 Tipo: ${absenceTypeName}
📝 Motivo: ${reason}
${notes ? `📋 Observaciones: ${notes}` : ''}
${hasAttachment ? '📎 Con documentación adjunta' : ''}

⏰ Notificado el: ${new Date().toLocaleString('es-ES')}

Este es un mensaje fehaciente con validez legal.
        `.trim();

        // Notificar a RRHH
        if (notifyHR) {
          const hrResult = await notificationService.sendFehacienteNotification({
            employeeId: 'HR_DEPT',
            senderId: employeeId || req.user.id,
            subject: `🚨 INASISTENCIA: ${employeeName} - ${absenceTypeName}`,
            content: notificationContent,
            priority: absenceType === 'emergency' ? 'alta' : 'media',
            documentType: 'absence_notification',
            metadata: {
              notificationType: 'absence_notification',
              absenceType: absenceType,
              employeeId: employeeId || req.user.id,
              startDate,
              endDate
            }
          });

          notification.notificationsSent.hrNotified = hrResult.success;
          console.log(`📧 RRHH notificado sobre inasistencia de ${employeeName}`);
        }

        // Notificar al médico
        if (notifyDoctor && (absenceType === 'medical' || doctorEmail)) {
          const doctorResult = await notificationService.sendFehacienteNotification({
            employeeId: 'MEDICAL_DEPT',
            senderId: employeeId || req.user.id,
            subject: `🏥 INASISTENCIA MÉDICA: ${employeeName}`,
            content: notificationContent,
            priority: 'media',
            documentType: 'medical_absence_notification',
            customEmail: doctorEmail,
            metadata: {
              notificationType: 'medical_absence_notification',
              employeeId: employeeId || req.user.id,
              startDate,
              endDate,
              doctorEmail
            }
          });

          notification.notificationsSent.doctorNotified = doctorResult.success;
          console.log(`🏥 Médico notificado sobre inasistencia médica de ${employeeName}`);
        }

        // Simular notificaciones SMS/WhatsApp/Email al empleado (confirmación)
        setTimeout(async () => {
          try {
            await notificationService.sendFehacienteNotification({
              employeeId: employeeId || req.user.id,
              senderId: 'SYSTEM',
              subject: '✅ Confirmación de Notificación de Inasistencia',
              content: `Tu notificación de inasistencia ${absenceTypeName} para ${dateRange} ha sido procesada y enviada correctamente a los responsables.`,
              priority: 'normal',
              documentType: 'absence_confirmation',
              metadata: {
                notificationType: 'absence_confirmation',
                originalNotificationId: notification.id
              }
            });
          } catch (confirmError) {
            console.error('Error enviando confirmación:', confirmError);
          }
        }, 2000);

      } catch (notificationError) {
        console.error('Error enviando notificaciones:', notificationError);
        // No fallar la request por error de notificación
      }

      res.status(201).json({
        success: true,
        message: 'Notificación de inasistencia enviada correctamente',
        data: {
          notificationId: notification.id,
          status: 'sent',
          sentAt: notification.createdAt,
          recipients: {
            hr: notification.notificationsSent.hrNotified,
            doctor: notification.notificationsSent.doctorNotified
          }
        }
      });

    } catch (error) {
      console.error('Error creando notificación de inasistencia:', error);
      res.status(500).json({
        success: false,
        error: 'Error interno del servidor',
        details: error.message
      });
    }
  }
);

// Subir documento de inasistencia
router.post('/upload-document',
  // auth,
  upload.single('document'),
  async (req, res) => {
    try {
      if (!req.file) {
        return res.status(400).json({
          success: false,
          error: 'No se proporcionó archivo'
        });
      }

      const { notificationId, fileType } = req.body;

      // Buscar la notificación
      const notification = absenceNotifications.find(n => n.id === notificationId);
      if (!notification) {
        return res.status(404).json({
          success: false,
          error: 'Notificación no encontrada'
        });
      }

      // Actualizar con la ruta del archivo
      notification.documentPath = req.file.path;
      notification.documentInfo = {
        originalName: req.file.originalname,
        filename: req.file.filename,
        size: req.file.size,
        mimetype: req.file.mimetype,
        fileType: fileType || 'document',
        uploadedAt: new Date()
      };

      res.json({
        success: true,
        message: 'Documento subido correctamente',
        data: {
          filename: req.file.filename,
          size: req.file.size,
          uploadedAt: notification.documentInfo.uploadedAt
        }
      });

    } catch (error) {
      console.error('Error subiendo documento:', error);
      res.status(500).json({
        success: false,
        error: 'Error subiendo documento',
        details: error.message
      });
    }
  }
);

// Obtener notificaciones de inasistencia del usuario
router.get('/my-notifications', auth, async (req, res) => {
  try {
    const userNotifications = absenceNotifications
      .filter(n => n.employeeId === req.user.id)
      .sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt));

    res.json({
      success: true,
      data: userNotifications.map(n => ({
        id: n.id,
        absenceType: n.absenceType,
        startDate: n.startDate,
        endDate: n.endDate,
        reason: n.reason,
        status: n.status,
        createdAt: n.createdAt,
        hasDocument: !!n.documentPath,
        responses: n.responses
      }))
    });

  } catch (error) {
    console.error('Error obteniendo notificaciones:', error);
    res.status(500).json({
      success: false,
      error: 'Error interno del servidor'
    });
  }
});

// Obtener todas las notificaciones (para admin/RRHH)
router.get('/all-notifications',
  auth,
  async (req, res) => {
    try {
      // Simular verificación de permisos admin
      if (!req.user || (req.user.role !== 'admin' && req.user.role !== 'hr')) {
        return res.status(403).json({
          success: false,
          error: 'Permisos insuficientes'
        });
      }

      const { status, absenceType, startDate, endDate } = req.query;
      let filteredNotifications = [...absenceNotifications];

      // Aplicar filtros
      if (status) {
        filteredNotifications = filteredNotifications.filter(n => n.status === status);
      }
      if (absenceType) {
        filteredNotifications = filteredNotifications.filter(n => n.absenceType === absenceType);
      }
      if (startDate) {
        const start = new Date(startDate);
        filteredNotifications = filteredNotifications.filter(n => new Date(n.startDate) >= start);
      }
      if (endDate) {
        const end = new Date(endDate);
        filteredNotifications = filteredNotifications.filter(n => new Date(n.startDate) <= end);
      }

      // Ordenar por fecha de creación (más recientes primero)
      filteredNotifications.sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt));

      res.json({
        success: true,
        data: filteredNotifications,
        total: filteredNotifications.length,
        filters: { status, absenceType, startDate, endDate }
      });

    } catch (error) {
      console.error('Error obteniendo todas las notificaciones:', error);
      res.status(500).json({
        success: false,
        error: 'Error interno del servidor'
      });
    }
  }
);

// Actualizar estado de notificación (aprobar/rechazar)
router.put('/update-status/:id',
  auth,
  [
    body('status').isIn(['approved', 'rejected', 'pending']).withMessage('Estado inválido'),
    body('processedBy').notEmpty().withMessage('Procesado por es obligatorio'),
  ],
  async (req, res) => {
    try {
      const errors = validationResult(req);
      if (!errors.isEmpty()) {
        return res.status(400).json({
          success: false,
          error: 'Datos inválidos',
          details: errors.array()
        });
      }

      const { id } = req.params;
      const { status, processedBy, comments } = req.body;

      const notification = absenceNotifications.find(n => n.id === id);
      if (!notification) {
        return res.status(404).json({
          success: false,
          error: 'Notificación no encontrada'
        });
      }

      // Actualizar notificación
      notification.status = status;
      notification.processedAt = new Date();
      notification.processedBy = processedBy;
      notification.processingComments = comments;

      // Enviar confirmación al empleado
      try {
        const statusText = status === 'approved' ? 'APROBADA' : 'RECHAZADA';
        const statusEmoji = status === 'approved' ? '✅' : '❌';
        
        await notificationService.sendFehacienteNotification({
          employeeId: notification.employeeId,
          senderId: req.user.id,
          subject: `${statusEmoji} Inasistencia ${statusText}`,
          content: `Tu solicitud de inasistencia del ${new Date(notification.startDate).toLocaleDateString('es-ES')} ha sido ${statusText.toLowerCase()}.\n\n${comments ? `Comentarios: ${comments}` : ''}\n\nProcesado por: ${processedBy}`,
          priority: 'alta',
          documentType: 'absence_response',
          metadata: {
            notificationType: 'absence_response',
            originalNotificationId: id,
            newStatus: status
          }
        });
      } catch (notifError) {
        console.error('Error enviando respuesta:', notifError);
      }

      res.json({
        success: true,
        message: `Notificación ${status === 'approved' ? 'aprobada' : 'rechazada'} correctamente`,
        data: {
          id: notification.id,
          status: notification.status,
          processedAt: notification.processedAt,
          processedBy: notification.processedBy
        }
      });

    } catch (error) {
      console.error('Error actualizando estado:', error);
      res.status(500).json({
        success: false,
        error: 'Error interno del servidor'
      });
    }
  }
);

module.exports = router;