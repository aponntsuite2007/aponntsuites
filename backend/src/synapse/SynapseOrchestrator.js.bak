/**
 * SYNAPSE ORCHESTRATOR - Test-Fix-Verify Inteligente con Discovery
 *
 * Integra:
 * - Discovery Engine (auto-descubrimiento de m√≥dulos)
 * - Config Generator (configs E2E desde discovery)
 * - Deadend Detector (detecci√≥n de callejones sin salida)
 * - Auto-Healing (reparaci√≥n autom√°tica)
 *
 * Flujo:
 * 1. Pre-check: ¬øExiste discovery? ‚Üí Si no, ejecutar discovery
 * 2. Pre-check: ¬øExiste config? ‚Üí Si no, generar desde discovery
 * 3. Pre-check: ¬øTiene deadends? ‚Üí Reportar y decidir si continuar
 * 4. Ejecutar test con config real
 * 5. Si falla por selector ‚Üí Re-ejecutar discovery
 * 6. Si falla por otro motivo ‚Üí Aplicar fixes
 * 7. Re-testear hasta MAX_RETRIES
 */

const { spawn, exec } = require('child_process');
const fs = require('fs');
const path = require('path');
const ConfigGenerator = require('./config-generator');
const DeadendDetector = require('./deadend-detector');

class SynapseOrchestrator {
  constructor(options = {}) {
    this.maxRetriesPerModule = options.maxRetries || 3;
    this.discoveryTimeout = options.discoveryTimeout || 300000; // 5 min
    this.testTimeout = options.testTimeout || 600000; // 10 min

    // Paths
    this.discoveryDir = path.join(__dirname, '..', '..', 'tests', 'e2e', 'discovery-results');
    this.configsDir = path.join(__dirname, '..', '..', 'tests', 'e2e', 'configs');
    this.resultsDir = path.join(__dirname, '..', '..', 'tests', 'e2e', 'results');
    this.logFile = path.join(__dirname, '..', '..', 'SYNAPSE-INTELLIGENT.md');

    // Components
    this.configGenerator = new ConfigGenerator();
    this.deadendDetector = new DeadendDetector();

    // Stats
    this.stats = {
      modulesProcessed: 0,
      modulesPassed: 0,
      modulesFailed: 0,
      modulesSkipped: 0,
      discoveriesRun: 0,
      configsGenerated: 0,
      deadendsDetected: 0,
      fixesApplied: 0
    };
  }

  /**
   * Ejecuta SYNAPSE completo en modo inteligente
   */
  async run(modules) {
    console.log('üöÄ SYNAPSE ORCHESTRATOR - MODO INTELIGENTE\n');
    console.log('üéØ Discovery + Config Auto-Gen + Deadend Detection\n');

    this.initLog();

    if (!modules || modules.length === 0) {
      modules = await this.getModulesFromDB();
    }

    console.log(`üìä Total m√≥dulos: ${modules.length}\n`);

    for (let i = 0; i < modules.length; i++) {
      const moduleKey = modules[i];
      console.log(`\n${'='.repeat(70)}`);
      console.log(`üìç M√≥dulo ${i + 1}/${modules.length}: ${moduleKey}`);
      console.log('='.repeat(70));

      await this.processModule(moduleKey, i + 1, modules.length);

      this.printProgress();
    }

    this.printFinalReport();
  }

  /**
   * Procesa UN m√≥dulo completo (con retries)
   */
  async processModule(moduleKey, moduleNum, totalModules) {
    let retries = 0;
    let modulePassed = false;

    while (retries < this.maxRetriesPerModule && !modulePassed) {
      const attemptNum = retries + 1;

      if (retries > 0) {
        console.log(`\nüîÑ Intento ${attemptNum}/${this.maxRetriesPerModule}`);
      }

      // ========================================
      // PASO 1: PRE-CHECK - ¬øExiste discovery?
      // ========================================
      const discoveryPath = path.join(this.discoveryDir, `${moduleKey}.discovery.json`);

      if (!fs.existsSync(discoveryPath)) {
        console.log(`\n‚ö†Ô∏è  Discovery no encontrado para ${moduleKey}`);
        console.log(`üîç Ejecutando auto-discovery...`);

        const discoverySuccess = await this.runDiscovery(moduleKey);

        if (!discoverySuccess) {
          console.log(`‚ùå Discovery fall√≥ - SALTANDO m√≥dulo`);
          this.stats.modulesSkipped++;
          this.logEntry(moduleKey, 'SKIPPED', 'Discovery failed', attemptNum);
          return;
        }

        this.stats.discoveriesRun++;
      } else {
        console.log(`‚úÖ Discovery existente encontrado`);
      }

      // ========================================
      // PASO 2: PRE-CHECK - ¬øExiste config?
      // ========================================
      const configPath = path.join(this.configsDir, `${moduleKey}.json`);

      if (!fs.existsSync(configPath)) {
        console.log(`\n‚ö†Ô∏è  Config no encontrado para ${moduleKey}`);
        console.log(`‚öôÔ∏è  Generando config desde discovery...`);

        try {
          this.configGenerator.generateAndSave(moduleKey);
          this.stats.configsGenerated++;
          console.log(`‚úÖ Config auto-generado exitosamente`);
        } catch (error) {
          console.log(`‚ùå Error generando config: ${error.message}`);
          this.stats.modulesSkipped++;
          this.logEntry(moduleKey, 'SKIPPED', 'Config generation failed', attemptNum);
          return;
        }
      } else {
        console.log(`‚úÖ Config existente encontrado`);
      }

      // ========================================
      // PASO 3: PRE-CHECK - ¬øTiene deadends?
      // ========================================
      console.log(`\nüîç Ejecutando detecci√≥n de deadends...`);

      const discovery = JSON.parse(fs.readFileSync(discoveryPath, 'utf8'));
      const deadends = await this.detectDeadends(moduleKey, discovery);

      if (deadends.status === 'CRITICAL') {
        console.log(`\nüî¥ DEADENDS CR√çTICOS detectados en ${moduleKey}`);
        console.log(`   ${deadends.message}`);
        console.log(`\nüìã Detalles:`);

        deadends.deadends
          .filter(d => d.severity === 'HIGH')
          .slice(0, 3)
          .forEach(d => {
            console.log(`   ‚ùå ${d.type}: ${d.field || d.button || 'N/A'}`);
            console.log(`      Raz√≥n: ${d.reason}`);
            console.log(`      Fix: ${d.suggestedFix.split('\n')[0]}`);
          });

        this.stats.deadendsDetected += deadends.summary.critical;

        // Decidir si continuar o skip
        if (deadends.summary.critical >= 3) {
          console.log(`\n‚ö†Ô∏è  Demasiados deadends cr√≠ticos (${deadends.summary.critical}) - SALTANDO`);
          this.stats.modulesSkipped++;
          this.logEntry(moduleKey, 'SKIPPED', `${deadends.summary.critical} critical deadends`, attemptNum);
          return;
        } else {
          console.log(`\n‚ö†Ô∏è  Continuando a pesar de ${deadends.summary.critical} deadends...`);
        }
      } else if (deadends.status === 'WARNING') {
        console.log(`‚ö†Ô∏è  ${deadends.message}`);
      } else {
        console.log(`‚úÖ Sin deadends detectados`);
      }

      // ========================================
      // PASO 4: EJECUTAR TEST
      // ========================================
      console.log(`\nüß™ Ejecutando test E2E...`);

      const testResult = await this.runTest(moduleKey);

      // ========================================
      // üÜï FIX #4: DETECTAR Y CORREGIR FALLBACK
      // ========================================
      const usedFallback = this.detectFallbackUsage(testResult.stdout);
      if (usedFallback) {
        console.log(`\nüîç FIX #4: Test us√≥ selector fallback - auto-corrigiendo config...`);
        const fixResult = await this.repairConfigSelector(moduleKey);
        if (fixResult.fixed) {
          this.stats.fixesApplied++;
          console.log(`   ‚úÖ Config actualizado: "${fixResult.oldSelector}" ‚Üí "${fixResult.newSelector}"`);
        } else if (fixResult.reason === 'already_fixed') {
          console.log(`   ‚ÑπÔ∏è  Config ya estaba correcto`);
        }
      }

      // ========================================
      // PASO 5: ANALIZAR RESULTADO
      // ========================================
      if (testResult.status === 'PASSED') {
        console.log(`\n‚úÖ ${moduleKey} PAS√ì exitosamente`);
        modulePassed = true;
        this.stats.modulesPassed++;
        this.logEntry(moduleKey, 'PASSED', testResult, attemptNum);
        return;
      }

      // ========================================
      // PASO 6: FALL√ì - Analizar tipo de error
      // ========================================
      console.log(`\n‚ùå ${moduleKey} FALL√ì`);

      const errorType = this.classifyError(testResult.stderr, testResult.stdout);
      console.log(`   Tipo de error: ${errorType}`);

      // ========================================
      // PASO 7: APLICAR FIX SEG√öN TIPO DE ERROR
      // ========================================
      if (errorType === 'SELECTOR_ERROR' && retries < this.maxRetriesPerModule - 1) {
        console.log(`\nüîß Error de selector detectado - Re-ejecutando discovery...`);

        const rediscoverySuccess = await this.runDiscovery(moduleKey);

        if (rediscoverySuccess) {
          console.log(`‚úÖ Re-discovery exitoso - Regenerando config...`);
          this.configGenerator.generateAndSave(moduleKey);
          this.stats.discoveriesRun++;
          this.stats.configsGenerated++;
        }

        // üî¥ CR√çTICO: TAMBI√âN aplicar fixes de frontend despu√©s de re-discovery
        console.log(`\nüîß Aplicando fixes de frontend...`);
        const fixResult = await this.applyFixes(moduleKey, errorType);

        if (fixResult.fixed) {
          console.log(`‚úÖ ${fixResult.count} fixes aplicados`);
          this.stats.fixesApplied += fixResult.count;
        } else {
          console.log(`‚ö†Ô∏è  ${fixResult.reason}`);
        }
      } else if (retries < this.maxRetriesPerModule - 1) {
        console.log(`\nüîß Intentando reparaci√≥n autom√°tica...`);

        const fixResult = await this.applyFixes(moduleKey, errorType);

        if (fixResult.fixed) {
          console.log(`‚úÖ ${fixResult.count} fixes aplicados`);
          this.stats.fixesApplied += fixResult.count;
        } else {
          console.log(`‚ö†Ô∏è  ${fixResult.reason}`);
        }
      }

      retries++;

      if (retries >= this.maxRetriesPerModule) {
        console.log(`\nüî¥ ${moduleKey} FALL√ì despu√©s de ${this.maxRetriesPerModule} intentos`);
        this.stats.modulesFailed++;
        this.logEntry(moduleKey, 'FAILED', testResult, attemptNum);
      }
    }

    this.stats.modulesProcessed++;
  }

  /**
   * Ejecuta discovery de un m√≥dulo
   */
  async runDiscovery(moduleKey) {
    return new Promise((resolve) => {
      const scriptPath = path.join(__dirname, '..', '..', 'scripts', 'discover-module-structure.js');

      console.log(`   üîç Spawning discovery process...`);

      const child = spawn('node', [scriptPath, moduleKey], {
        cwd: path.join(__dirname, '..', '..'),
        stdio: 'pipe'
      });

      let output = '';

      child.stdout.on('data', (data) => {
        output += data.toString();
      });

      child.stderr.on('data', (data) => {
        process.stderr.write(data);
      });

      // Timeout
      const timeout = setTimeout(() => {
        child.kill();
        console.log(`   ‚è∞ Discovery timeout (${this.discoveryTimeout/1000}s)`);
        resolve(false);
      }, this.discoveryTimeout);

      child.on('close', (code) => {
        clearTimeout(timeout);

        if (code === 0) {
          console.log(`   ‚úÖ Discovery completado exitosamente`);
          resolve(true);
        } else {
          console.log(`   ‚ùå Discovery fall√≥ (exit code: ${code})`);
          resolve(false);
        }
      });

      child.on('error', (error) => {
        clearTimeout(timeout);
        console.log(`   ‚ùå Discovery error: ${error.message}`);
        resolve(false);
      });
    });
  }

  /**
   * Ejecuta test E2E de un m√≥dulo
   */
  async runTest(moduleKey) {
    return new Promise((resolve) => {
      const startTime = Date.now();
      const command = `npx playwright test tests/e2e/modules/universal-modal-advanced.e2e.spec.js --project=chromium`;

      const child = exec(command, {
        cwd: path.join(__dirname, '..', '..'),
        timeout: this.testTimeout,
        maxBuffer: 10 * 1024 * 1024,
        env: {
          ...process.env,
          MODULE_TO_TEST: moduleKey,
          BRAIN_INTEGRATION: 'false'
        }
      });

      let stdout = '';
      let stderr = '';

      child.stdout.on('data', (data) => {
        stdout += data;
        process.stdout.write(data);
      });

      child.stderr.on('data', (data) => {
        stderr += data;
      });

      child.on('close', (code) => {
        const duration = Date.now() - startTime;
        const durationMin = (duration / 1000 / 60).toFixed(1);

        const passedMatch = stdout.match(/(\d+)\s+passed/);
        const failedMatch = stdout.match(/(\d+)\s+failed/);
        const skippedMatch = stdout.match(/(\d+)\s+skipped/);

        const passed = passedMatch ? parseInt(passedMatch[1]) : 0;
        const failed = failedMatch ? parseInt(failedMatch[1]) : 0;
        const skipped = skippedMatch ? parseInt(skippedMatch[1]) : 0;

        // üî¥ NUEVO: Tests skipped = FAILED (necesita repair)
        let status;
        if (skipped >= 3) {
          status = 'FAILED'; // 3+ tests skipped = selector issues = REPAIR NEEDED
        } else if (code === 0 && passed > 0) {
          status = 'PASSED';
        } else {
          status = 'FAILED';
        }

        resolve({
          status,
          passed,
          failed,
          skipped, // üî¥ NUEVO: Agregar skipped al resultado
          total: passed + failed + skipped,
          duration: durationMin,
          exitCode: code,
          stdout,
          stderr
        });
      });

      child.on('error', (error) => {
        resolve({
          status: 'ERROR',
          error: error.message,
          stdout: '',
          stderr: error.stack
        });
      });
    });
  }

  /**
   * Detecta deadends en un m√≥dulo
   */
  async detectDeadends(moduleKey, discovery) {
    // An√°lisis est√°tico (sin page)
    const deadends = [];

    // Detectar dependencias rotas
    const brokenDeps = await this.deadendDetector.detectBrokenDependencies(discovery);
    deadends.push(...brokenDeps);

    // Detectar circuitos de datos
    const circuits = await this.deadendDetector.detectBrokenCircuits(discovery);
    deadends.push(...circuits);

    const report = this.deadendDetector.generateReport(deadends);

    // Guardar reporte
    this.deadendDetector.saveReport(moduleKey, report);

    return report;
  }

  /**
   * üÜï FIX #4: Detecta si el test us√≥ fallback selector
   */
  detectFallbackUsage(stdout) {
    if (!stdout) return false;
    const fallbackPatterns = [
      /‚úÖ\s+Fallback\s+exitoso/i,
      /continuando\s+con\s+#mainContent/i,
      /usando\s+selector\s+fallback/i
    ];
    return fallbackPatterns.some(pattern => pattern.test(stdout));
  }

  /**
   * üÜï FIX #4: Auto-corrige el config para usar #mainContent directamente
   */
  async repairConfigSelector(moduleKey) {
    const configPath = path.join(__dirname, '..', '..', 'tests', 'e2e', 'configs', `${moduleKey}.json`);
    if (!fs.existsSync(configPath)) {
      console.log(`‚ö†Ô∏è Config no existe: ${configPath}`);
      return { fixed: false, reason: 'config_not_found' };
    }
    try {
      const config = JSON.parse(fs.readFileSync(configPath, 'utf-8'));
      if (config.waitForSelector === '#mainContent') {
        console.log(`‚ÑπÔ∏è Config ya usa #mainContent - no requiere fix`);
        return { fixed: false, reason: 'already_fixed' };
      }
      const backupPath = configPath.replace('.json', '.backup.json');
      fs.writeFileSync(backupPath, JSON.stringify(config, null, 2));
      const oldSelector = config.waitForSelector;
      config.waitForSelector = '#mainContent';
      fs.writeFileSync(configPath, JSON.stringify(config, null, 2));
      console.log(`‚úÖ FIX #4 aplicado: "${oldSelector}" ‚Üí "#mainContent"`);
      console.log(`   Backup: ${path.basename(backupPath)}`);
      return { fixed: true, oldSelector, newSelector: '#mainContent', backupPath };
    } catch (error) {
      console.error(`‚ùå Error aplicando FIX #4: ${error.message}`);
      return { fixed: false, reason: error.message };
    }
  }

  /**
   * Clasifica tipo de error
   */
  classifyError(stderr, stdout) {
    const combined = (stderr + stdout).toLowerCase();

    // üî¥ NUEVO: Detectar fallbacks del test (selector no encontrado)
    if (combined.includes('‚ö†Ô∏è  selector') && combined.includes('no encontrado')) {
      return 'SELECTOR_ERROR';
    }

    if (combined.includes('intentando fallback')) {
      return 'SELECTOR_ERROR';
    }

    if (combined.includes('skipping') && combined.includes('test')) {
      return 'SELECTOR_ERROR';
    }

    if (combined.includes('locator') || combined.includes('selector') || combined.includes('element not found')) {
      return 'SELECTOR_ERROR';
    }

    if (combined.includes('timeout') || combined.includes('timed out')) {
      return 'TIMEOUT_ERROR';
    }

    if (combined.includes('network') || combined.includes('econnrefused')) {
      return 'NETWORK_ERROR';
    }

    if (combined.includes('assertion') || combined.includes('expected')) {
      return 'ASSERTION_ERROR';
    }

    return 'UNKNOWN_ERROR';
  }

  /**
   * Aplica fixes autom√°ticos
   */
  async applyFixes(moduleKey, errorType) {
    const { Pool } = require('pg');
    const pool = new Pool({
      host: 'localhost',
      port: 5432,
      database: 'attendance_system',
      user: 'postgres',
      password: 'Aedr15150302'
    });

    let fixesApplied = 0;

    try {
      // FIX 1: Activar m√≥dulo en ISI
      const activeModulesResult = await pool.query(`
        SELECT active_modules::text FROM companies WHERE slug = 'isi'
      `);

      if (activeModulesResult.rows.length > 0) {
        const activeModules = JSON.parse(activeModulesResult.rows[0].active_modules);

        if (!activeModules.includes(moduleKey)) {
          console.log(`   üîß FIX #1: Activando m√≥dulo en ISI...`);
          activeModules.push(moduleKey);

          await pool.query(`
            UPDATE companies SET active_modules = $1::jsonb WHERE slug = 'isi'
          `, [JSON.stringify(activeModules)]);

          fixesApplied++;
        }
      }

      // FIX 2: Activar en company_modules
      const moduleCheck = await pool.query(`
        SELECT sm.id as system_module_id, cm.activo
        FROM system_modules sm
        LEFT JOIN company_modules cm ON sm.id = cm.system_module_id AND cm.company_id = 11
        WHERE sm.module_key = $1
      `, [moduleKey]);

      if (moduleCheck.rows.length > 0 && !moduleCheck.rows[0].activo) {
        console.log(`   üîß FIX #2: Activando m√≥dulo en company_modules...`);

        await pool.query(`
          INSERT INTO company_modules (company_id, system_module_id, activo)
          VALUES (11, $1, true)
          ON CONFLICT (company_id, system_module_id)
          DO UPDATE SET activo = true
        `, [moduleCheck.rows[0].system_module_id]);

        fixesApplied++;
      }

      // FIX 3: REPAIR FRONTEND STRUCTURE (botones CRUD faltantes)
      if (errorType === 'SELECTOR_ERROR') {
        console.log(`   üîß FIX #3: Reparando estructura frontend...`);
        const frontendRepaired = await this.repairFrontendStructure(moduleKey);
        if (frontendRepaired) {
          fixesApplied++;
        }
      }

    } catch (error) {
      console.log(`   ‚ö†Ô∏è  Error aplicando fixes: ${error.message}`);
    } finally {
      await pool.end();
    }

    if (fixesApplied > 0) {
      return { fixed: true, count: fixesApplied };
    }

    return { fixed: false, reason: 'Sin fixes autom√°ticos disponibles' };
  }

  /**
   * Repara estructura frontend (agrega botones CRUD faltantes)
   */
  async repairFrontendStructure(moduleKey) {
    const frontendPath = path.join(__dirname, '..', '..', 'public', 'js', 'modules', `${moduleKey}.js`);

    // Verificar si el archivo existe
    if (!fs.existsSync(frontendPath)) {
      console.log(`      ‚ö†Ô∏è  Archivo frontend no existe: ${frontendPath}`);
      return false;
    }

    try {
      let content = fs.readFileSync(frontendPath, 'utf8');
      let modified = false;

      // Verificar si ya tiene bot√≥n CREATE con data-action
      const hasCreateButton = content.includes('data-action="open"') ||
                              content.includes('data-action="create"') ||
                              content.includes('btn-create');

      if (!hasCreateButton) {
        console.log(`      üîß Agregando bot√≥n CREATE con data-action...`);

        // Buscar la funci√≥n init() o render() para agregar bot√≥n
        const initMatch = content.match(/(function\s+init\s*\(|init:\s*function\s*\(|const\s+init\s*=|async\s+init\s*\(|\s+init\s*\()/);

        if (initMatch) {
          // Crear snippet de bot√≥n CREATE
          const createButtonSnippet = `
  // üîß AUTO-REPAIR: Bot√≥n CREATE agregado por SYNAPSE
  const createButton = document.createElement('button');
  createButton.className = 'btn btn-primary btn-create';
  createButton.setAttribute('data-action', 'open');
  createButton.innerHTML = '<i class="fas fa-plus"></i> Crear Nuevo';
  createButton.onclick = () => {
    console.log('üîß [AUTO-REPAIR] Click en bot√≥n CREATE - abrir modal');
    // TODO: Implementar apertura de modal
  };

  // Buscar contenedor y agregar bot√≥n
  const container = document.querySelector('#mainContent') || document.querySelector('.content');
  if (container && !container.querySelector('.btn-create')) {
    const btnContainer = document.createElement('div');
    btnContainer.className = 'mb-3';
    btnContainer.appendChild(createButton);
    container.insertBefore(btnContainer, container.firstChild);
  }
`;

          // Buscar d√≥nde insertar (despu√©s de init o al inicio del render)
          const insertPosition = content.indexOf('{', initMatch.index) + 1;

          content = content.slice(0, insertPosition) +
                   createButtonSnippet +
                   content.slice(insertPosition);

          modified = true;
          console.log(`      ‚úÖ Bot√≥n CREATE agregado en funci√≥n init()`);
        } else {
          console.log(`      ‚ö†Ô∏è  No se encontr√≥ funci√≥n init() para agregar bot√≥n`);
        }
      } else {
        console.log(`      ‚úÖ Bot√≥n CREATE ya existe`);
      }

      // Guardar cambios si hubo modificaciones
      if (modified) {
        // Backup del archivo original
        const backupPath = frontendPath.replace('.js', '.backup.js');
        fs.copyFileSync(frontendPath, backupPath);
        console.log(`      üíæ Backup guardado: ${path.basename(backupPath)}`);

        // Guardar archivo modificado
        fs.writeFileSync(frontendPath, content, 'utf8');
        console.log(`      ‚úÖ Archivo frontend reparado`);
        return true;
      }

      return false;

    } catch (error) {
      console.log(`      ‚ùå Error reparando frontend: ${error.message}`);
      return false;
    }
  }

  /**
   * Obtiene m√≥dulos desde BD
   */
  async getModulesFromDB() {
    const { Pool } = require('pg');
    const pool = new Pool({
      host: 'localhost',
      port: 5432,
      database: 'attendance_system',
      user: 'postgres',
      password: 'Aedr15150302'
    });

    const result = await pool.query(`
      SELECT module_key
      FROM system_modules
      WHERE is_active = true
        AND (module_type IS NULL OR module_type != 'submodule')
        AND available_in IN ('empresa', 'company', 'both')
      ORDER BY is_core DESC, module_key
    `);

    await pool.end();
    return result.rows.map(r => r.module_key);
  }

  /**
   * Inicializa archivo de log
   */
  initLog() {
    const header = `# SYNAPSE ORCHESTRATOR - EJECUCI√ìN INTELIGENTE

**Fecha**: ${new Date().toISOString()}
**Modo**: Discovery + Config Auto-Gen + Deadend Detection

---

`;
    fs.writeFileSync(this.logFile, header, 'utf8');
  }

  /**
   * Escribe entrada en log
   */
  logEntry(moduleKey, status, details, attemptNum) {
    let entry = `## ${this.stats.modulesProcessed + 1}. ${moduleKey} (Intento ${attemptNum})\n\n`;
    entry += `- **Status**: ${status}\n`;

    if (typeof details === 'object' && details.passed !== undefined) {
      entry += `- **Tests**: ${details.passed}/${details.total}\n`;

      // üî¥ NUEVO: Mostrar skipped si hay
      if (details.skipped > 0) {
        entry += `- **‚ö†Ô∏è Skipped**: ${details.skipped} (requiere repair)\n`;
      }

      entry += `- **Duraci√≥n**: ${details.duration} min\n`;
    } else if (typeof details === 'string') {
      entry += `- **Raz√≥n**: ${details}\n`;
    }

    entry += `\n---\n\n`;

    fs.appendFileSync(this.logFile, entry, 'utf8');
  }

  /**
   * Imprime progreso actual
   */
  printProgress() {
    const total = this.stats.modulesProcessed;

    if (total === 0) return;

    const passRate = Math.round((this.stats.modulesPassed / total) * 100);

    console.log(`\n${'‚îÄ'.repeat(70)}`);
    console.log('üìä PROGRESO GLOBAL:');
    console.log(`   Procesados: ${total}`);
    console.log(`   ‚úÖ PASSED: ${this.stats.modulesPassed} (${passRate}%)`);
    console.log(`   ‚ùå FAILED: ${this.stats.modulesFailed}`);
    console.log(`   ‚è≠Ô∏è  SKIPPED: ${this.stats.modulesSkipped}`);
    console.log(`\n   üîç Discoveries: ${this.stats.discoveriesRun}`);
    console.log(`   ‚öôÔ∏è  Configs generados: ${this.stats.configsGenerated}`);
    console.log(`   üö´ Deadends detectados: ${this.stats.deadendsDetected}`);
    console.log(`   üîß Fixes aplicados: ${this.stats.fixesApplied}`);
    console.log('‚îÄ'.repeat(70));
  }

  /**
   * Imprime reporte final
   */
  printFinalReport() {
    const total = this.stats.modulesProcessed;
    const passRate = total > 0 ? Math.round((this.stats.modulesPassed / total) * 100) : 0;

    const report = `

# REPORTE FINAL

**Fecha**: ${new Date().toISOString()}

## Resultados

- **Total procesados**: ${total}
- **‚úÖ PASSED**: ${this.stats.modulesPassed} (${passRate}%)
- **‚ùå FAILED**: ${this.stats.modulesFailed}
- **‚è≠Ô∏è SKIPPED**: ${this.stats.modulesSkipped}

## Actividad del Sistema

- **üîç Discoveries ejecutados**: ${this.stats.discoveriesRun}
- **‚öôÔ∏è Configs auto-generados**: ${this.stats.configsGenerated}
- **üö´ Deadends detectados**: ${this.stats.deadendsDetected}
- **üîß Fixes aplicados**: ${this.stats.fixesApplied}

${passRate >= 90 ? 'üéâ **EXCELENTE PASS RATE**' : passRate >= 70 ? '‚úÖ **BUEN PASS RATE**' : '‚ö†Ô∏è **REQUIERE ATENCI√ìN**'}
`;

    fs.appendFileSync(this.logFile, report, 'utf8');

    console.log('\n' + '='.repeat(70));
    console.log('üèÅ SYNAPSE ORCHESTRATOR - COMPLETADO');
    console.log('='.repeat(70));
    console.log(`‚úÖ PASSED: ${this.stats.modulesPassed}/${total} (${passRate}%)`);
    console.log(`‚ùå FAILED: ${this.stats.modulesFailed}/${total}`);
    console.log(`‚è≠Ô∏è  SKIPPED: ${this.stats.modulesSkipped}/${total}`);
    console.log(`\nüìÑ Log completo: SYNAPSE-INTELLIGENT.md\n`);
  }
}

module.exports = SynapseOrchestrator;

// CLI Usage
if (require.main === module) {
  const orchestrator = new SynapseOrchestrator();

  const args = process.argv.slice(2);

  if (args.length > 0) {
    // M√≥dulos espec√≠ficos
    orchestrator.run(args).catch(console.error);
  } else {
    // Todos los m√≥dulos desde BD
    orchestrator.run().catch(console.error);
  }
}
